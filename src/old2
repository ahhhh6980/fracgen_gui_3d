/*
    Copyright (C) 2022  Shelby Lynn B.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/
// ui.with_layout(ctx, add_contents)
            // egui::CentralPanel::default().show(ctx, |ui| {
            ui.vertical_centered(|ui| {
                let rect = ctx.available_rect();
                ui.set_height(rect.height() - self.node_menu_height);
                ui.horizontal_centered(|ui| {
                    let mut top_height = 0.0;
                    ui.with_layout(egui::Layout::top_down_justified(egui::Align::LEFT), |ui| {
                        let rect = ui.max_rect();
                        let painter = ui.painter();
                        painter.rect_filled(rect, 0.0, Color32::from_rgb(20, 20, 20));
                        // ui.set_width_range(128, 256.0)
                        // let spacing =;
                        // ui.set_width(self.input_menu.width);
                        // ui.shrink_width_to_current();
                        // top_height = ui.available_height();
                        // ui.style_mut().spacing.item_spacing.x = 0.0;

                        // let (mut cr, mut wr, mut hr) = (Response);
                        egui::Window::new("Options (WIP)").show(ctx, |ui| {
                            ui.horizontal_top(|ui| {
                                // ui.set_width(ui.available_width());

                                // ui.add_sized(
                                //     Vec2 {
                                //         x: ui.available_width(),
                                //         y: 16.0,
                                //     },

                                // ui.indent(id_source, add_contents)
                                ui.vertical(|ui| {
                                    egui::Grid::new("Input_grid")
                                        .num_columns(10)
                                        .show(ui, |ui| {
                                            ui.set_height(16.0);
                                            ui.set_width(ui.available_width());

                                            ui.label("Viewport: ");
                                            ui.label("Size: ");
                                            let width_response = ui.add(
                                                TextEdit::singleline(
                                                    &mut self.input_menu.viewport_size.0,
                                                )
                                                .hint_text("Viewport Width"),
                                            );
                                            let height_response = ui.add(
                                                TextEdit::singleline(
                                                    &mut self.input_menu.viewport_size.1,
                                                )
                                                .hint_text("Viewport Height"),
                                            );
                                            ui.add(Checkbox::new(
                                                &mut self.input_menu.viewport_size.2,
                                                "Keep Ratio?",
                                            ));
                                            ui.label("Samples: ");
                                            ui.add(
                                                TextEdit::singleline(
                                                    &mut self
                                                        .viewport
                                                        .renderer
                                                        .rendered_samples
                                                        .to_string(),
                                                )
                                                .hint_text("Viewport Samples")
                                                .interactive(false),
                                            );

                                            if width_response.lost_focus()
                                                && ui.input().key_pressed(egui::Key::Enter)
                                            {
                                                if let Ok(new_w) =
                                                    self.input_menu.viewport_size.0.parse::<f32>()
                                                {
                                                    let mut new_h = if let Some((_, new_h)) =
                                                        self.viewport.needs_resize
                                                    {
                                                        new_h
                                                    } else {
                                                        self.viewport.image_size.1 as f32
                                                    };
                                                    if self.input_menu.viewport_size.2 {
                                                        new_h = new_h * (new_w as f32 / new_h);
                                                        self.input_menu.viewport_size.1 =
                                                            (new_h.round() as usize).to_string();
                                                    }
                                                    self.viewport.needs_resize =
                                                        Some((new_w, new_h));
                                                } else {
                                                    self.input_menu.viewport_size.0 =
                                                        if let Some((new_w, _)) =
                                                            self.viewport.needs_resize
                                                        {
                                                            new_w.to_string()
                                                        } else {
                                                            self.viewport.image_size.0.to_string()
                                                        };
                                                }
                                            }

                                            if height_response.lost_focus()
                                                && ui.input().key_pressed(egui::Key::Enter)
                                            {
                                                if let Ok(new_h) =
                                                    self.input_menu.viewport_size.1.parse::<f32>()
                                                {
                                                    let mut new_w = if let Some((new_w, _)) =
                                                        self.viewport.needs_resize
                                                    {
                                                        new_w
                                                    } else {
                                                        self.viewport.image_size.0 as f32
                                                    };
                                                    if self.input_menu.viewport_size.2 {
                                                        new_w = new_w * (new_h as f32 / new_w);
                                                        self.input_menu.viewport_size.0 =
                                                            (new_w.round() as usize).to_string();
                                                    }
                                                    self.viewport.needs_resize =
                                                        Some((new_w, new_h));
                                                } else {
                                                    self.input_menu.viewport_size.1 =
                                                        if let Some((new_w, _)) =
                                                            self.viewport.needs_resize
                                                        {
                                                            new_w.to_string()
                                                        } else {
                                                            self.viewport.image_size.1.to_string()
                                                        };
                                                }
                                            }
                                            ui.end_row();
                                            ui.label("Export: ");
                                            ui.label("Size: ");
                                            let export_width_response = ui.add(
                                                TextEdit::singleline(
                                                    &mut self.input_menu.export_size.0,
                                                )
                                                .hint_text("Export Width"),
                                            );
                                            let export_height_response = ui.add(
                                                TextEdit::singleline(
                                                    &mut self.input_menu.export_size.1,
                                                )
                                                .hint_text("Export Height"),
                                            );
                                            ui.add(Checkbox::new(
                                                &mut self.input_menu.export_size.2,
                                                "Keep Ratio?",
                                            ));
                                            ui.label("Samples: ");
                                            let samples_response = ui.add(
                                                TextEdit::singleline(&mut self.input_menu.samples)
                                                    .hint_text("Export Samples"),
                                            );
                                            ui.end_row();

                                            if export_width_response.lost_focus()
                                                && ui.input().key_pressed(egui::Key::Enter)
                                            {
                                                if let Ok(new_w) =
                                                    self.input_menu.export_size.0.parse::<f32>()
                                                {
                                                    let mut new_h = self.renderer.size.1 as f32;
                                                    if self.input_menu.export_size.2 {
                                                        let ratio =
                                                            new_w / self.renderer.size.0 as f32;
                                                        new_h *= ratio;
                                                        println!("NEW : {}", new_h);
                                                        self.input_menu.export_size.1 =
                                                            (new_h.round() as usize).to_string();
                                                    }
                                                    self.renderer.size = (
                                                        new_w.round() as usize,
                                                        new_h.round() as usize,
                                                    );
                                                    self.renderer.raw =
                                                        Image::new(self.renderer.size);
                                                    self.input_menu.export_size.0 =
                                                        (new_w.round() as usize).to_string();
                                                } else {
                                                    self.input_menu.export_size.0 =
                                                        self.renderer.size.0.to_string();
                                                }
                                            }

                                            if export_height_response.lost_focus()
                                                && ui.input().key_pressed(egui::Key::Enter)
                                            {
                                                if let Ok(new_h) =
                                                    self.input_menu.export_size.1.parse::<f32>()
                                                {
                                                    let mut new_w = self.renderer.size.0 as f32;
                                                    if self.input_menu.export_size.2 {
                                                        let ratio =
                                                            new_h / self.renderer.size.1 as f32;
                                                        new_w *= ratio;
                                                        println!("NEW : {}", new_w);
                                                        self.input_menu.export_size.0 =
                                                            (new_w.round() as usize).to_string();
                                                    }
                                                    self.renderer.size = (
                                                        new_w.round() as usize,
                                                        new_h.round() as usize,
                                                    );
                                                    self.renderer.raw =
                                                        Image::new(self.renderer.size);
                                                    self.input_menu.export_size.1 =
                                                        (new_h.round() as usize).to_string();
                                                } else {
                                                    self.input_menu.export_size.1 =
                                                        self.renderer.size.1.to_string();
                                                }
                                            }

                                            // ui.radio_value(
                                            //     &mut self.viewport.renderer.args.hue_offset,
                                            //     1.0,
                                            //     "?",
                                            // )
                                            // ui.sli
                                        })
                                });

                                // let half = Vec2 {
                                //     x: (ui.available_width() / 3.0) - 8.0,
                                //     y: 16.0,
                                // };
                                // (
                                //     ui.add_sized(
                                //         Vec2 { x: 16.0, y: 16.0 },
                                //         ,
                                //     ),
                                //     ui.add_sized(
                                //         half,
                                //         ,
                                //     ),
                                //     ui.add_sized(
                                //         half,
                                //         ,
                                //     ),
                                //     ui.add_sized(
                                //         half,
                                //         TextEdit::singleline(&mut self.input_menu.size_input.1)
                                //             .hint_text("Viewport Height"),
                                //     ),
                                // )
                            });
                            ui.separator();
                            egui::Grid::new("ass2").show(ui, |ui| {
                                ui.label("Iter Method:");
                                ui.add(
                                    TextEdit::singleline(
                                        &mut self
                                            .viewport
                                            .renderer
                                            .args
                                            .iter_funct_choice
                                            .to_string(),
                                    )
                                    .hint_text("Iter Method")
                                    .interactive(false),
                                );
                                ui.label("Bail Method:");
                                ui.add(
                                    TextEdit::singleline(
                                        &mut self
                                            .viewport
                                            .renderer
                                            .args
                                            .conditional_choice
                                            .to_string(),
                                    )
                                    .hint_text("Cond Method")
                                    .interactive(false),
                                );
                                ui.label("Coloring Method:");
                                ui.add(
                                    TextEdit::singleline(
                                        &mut self
                                            .viewport
                                            .renderer
                                            .args
                                            .color_funct_choice
                                            .to_string(),
                                    )
                                    .hint_text("Color Method")
                                    .interactive(false),
                                );
                            });
                            // let idfk =
                            // egui::Grid::new("lashdajshdkljashd").show(ui, |ui| {
                            //     ui.label("Origin:");
                            //     ui.label("Julia:");
                            //     ui.end_row();
                            // });
                            let huh = ui.available_width() - 32.0;
                            egui::Grid::new("Positioning").show(ui, |ui| {
                                let alt = Complex64::new(f64::NAN, f64::NAN);
                                ui.add_sized(
                                    (huh / 6.0 - 1.0, 8.0),
                                    egui::Label::new("Origin: ").wrap(true),
                                );
                                // ui.label("Origin: ");
                                ui.add_sized(
                                    (huh / 6.0, 0.0),
                                    TextEdit::singleline(
                                        &mut self.viewport.renderer.origin.re.to_string(),
                                    )
                                    .hint_text("Origin Re")
                                    .interactive(false),
                                );
                                ui.add_sized(
                                    (huh / 6.0, 0.0),
                                    TextEdit::singleline(
                                        &mut self.viewport.renderer.origin.im.to_string(),
                                    )
                                    .hint_text("Origin Im")
                                    .interactive(false),
                                );
                                ui.add_sized(
                                    (huh / 6.0 - 8.0, 16.0),
                                    egui::Label::new("Julia: ").wrap(true),
                                );
                                // ui.label("Julia: ");
                                ui.add_sized(
                                    (huh / 6.0, 0.0),
                                    TextEdit::singleline(
                                        &mut self
                                            .viewport
                                            .renderer
                                            .args
                                            .julia
                                            .unwrap_or(alt)
                                            .re
                                            .to_string(),
                                    )
                                    .hint_text("Julia Re")
                                    .interactive(false),
                                );
                                ui.add_sized(
                                    (huh / 6.0, 0.0),
                                    TextEdit::singleline(
                                        &mut self
                                            .viewport
                                            .renderer
                                            .args
                                            .julia
                                            .unwrap_or(alt)
                                            .im
                                            .to_string(),
                                    )
                                    .hint_text("Julia Im")
                                    .interactive(false),
                                );
                                ui.end_row();
                            });
                            ui.separator();
                            ui.horizontal_top(|ui| {
                                egui::Grid::new("ass").show(ui, |ui| {
                                    ui.vertical(|ui| {
                                        let color =
                                            Rgb::from_color(self.viewport.renderer.args.set_color)
                                                .to_arr()
                                                .0;
                                        // let mut color = epaint::Rgba::new() {
                                        //     0: [
                                        //         color[0] as f32,
                                        //         color[1] as f32,
                                        //         color[2] as f32,
                                        //         color[3] as f32,
                                        //     ],
                                        // };

                                        let mut color = Hsva::from_rgba_unmultiplied(
                                            color[0] as f32,
                                            color[1] as f32,
                                            color[2] as f32,
                                            color[3] as f32,
                                        );
                                        // let response = ui.color_edit_button_rgba_unmultiplied(&mut color);
                                        // color_picker::show_color(ui, color, desired_size)
                                        let InnerResponse::<()> { inner, response } =
                                            ui.vertical(|ui| {
                                                color_picker::color_picker_hsva_2d(
                                                    ui,
                                                    &mut color,
                                                    color_picker::Alpha::OnlyBlend,
                                                );
                                            });

                                        let color = color.to_rgba_unmultiplied();
                                        let new_arr = [
                                            color[0] as f64,
                                            color[1] as f64,
                                            color[2] as f64,
                                            color[3] as f64,
                                        ];
                                        self.viewport.renderer.args.set_color =
                                            Srgb::from_color(Rgb::new(new_arr));
                                    });

                                    ui.vertical(|ui| {
                                        let result = ui.add(
                                            egui::Slider::new(
                                                &mut self.viewport.renderer.args.hue_offset_pre_exp,
                                                0.0..=360.0,
                                            )
                                            .logarithmic(true)
                                            .text("Hue Shift PreExp"),
                                        );
                                        if result.changed() {
                                            pressed = true;
                                        }

                                        let result = ui.add(
                                            egui::Slider::new(
                                                &mut self
                                                    .viewport
                                                    .renderer
                                                    .args
                                                    .hue_offset_post_exp,
                                                0.0..=360.0,
                                            )
                                            .text("Hue Shift PostExp"),
                                        );
                                        if result.changed() {
                                            pressed = true;
                                        }

                                        let result = ui.add(
                                            egui::Slider::new(
                                                &mut self.viewport.renderer.args.hue_scale,
                                                0.1..=10.0,
                                            )
                                            .text("Hue Scale"),
                                        );
                                        if result.changed() {
                                            pressed = true;
                                        }

                                        let result = ui.add(
                                            egui::Slider::new(
                                                &mut self.viewport.renderer.args.hue_exponent,
                                                1.0..=2.0,
                                            )
                                            .logarithmic(true)
                                            .text("Hue Exp"),
                                        );
                                        if result.changed() {
                                            pressed = true;
                                        }
                                    });
                                });
                            });
                            ui.separator();
                        })
                    });
                    ui.with_layout(egui::Layout::top_down_justified(egui::Align::LEFT), |ui| {
                        // Load our rendered image into viewport
                        self.viewport.texture = None;
                        let texture: &egui::TextureHandle =
                            self.viewport.texture.get_or_insert_with(|| {
                                ctx.load_texture(
                                    "my-image",
                                    image_to_colorimage(&self.viewport.renderer.process_image()),
                                )
                            });
                        ui.with_layout(egui::Layout::top_down_justified(egui::Align::LEFT), |ui| {
                            let (vw, vh) = (ui.available_width(), ui.available_height());
                            let (rw, rh) =
                                (self.viewport.image.width(), self.viewport.image.height());
                            let l_space = ui.spacing().scroll_bar_width + 2.0;
                            let t_space = 30.0;
                            let (w, h);
                            // Compute new bounds for our viewport
                            if vh > vw {
                                w = ui.available_width();
                                h = rh as f32 * (w as f32 / rw as f32);
                            } else {
                                h = ui.available_height();
                                w = rw as f32 * (h as f32 / rh as f32);
                            }
                            self.viewport.img_empty_space =
                                (ui.available_width() - w, ui.available_height() - h);
                            // self.input_menu.width += self.viewport.img_empty_space.0;
                            top_height += self.viewport.img_empty_space.1;
                            // if h != top_height {
                            //     self.input_menu.width -= ui.available_width()
                            //         * ((ui.available_height() - h) / ui.available_height())
                            // }

                            // Apply the viewport
                            let ictx = ui.image(texture, egui::Vec2::new(w as f32, h as f32)).ctx;
                            // Figure out where our pointer is on the viewport

                            self.pointer = if !color_interact {
                                ictx.pointer_hover_pos()
                            } else {
                                None
                            };
                            self.renderer.origin = self.viewport.last.origin;

                            if let Some(pointer_pos) = self.pointer {
                                let scalar = self.viewport.image_size.0 as f32 / w as f32;
                                let ipxpos = (
                                    (pointer_pos.x - l_space) * scalar,
                                    (pointer_pos.y - t_space) * scalar,
                                );
                                let old_origin = self.viewport.renderer.origin;
                                // let old_origin = self.viewport.renderer.origin;
                                if (0..self.viewport.image_size.0 as i32)
                                    .contains(&(ipxpos.0.floor() as i32))
                                    && (0..self.viewport.image_size.1 as i32)
                                        .contains(&(ipxpos.1.ceil() as i32))
                                    && self.viewport.active
                                    && !self.viewport.renderer.rendering
                                {
                                    if let Some(v) = self.events.scroll {
                                        let mut q = v.y;
                                        if axis_bool {
                                            q = v.x;
                                        }
                                        if q.signum() < 0.0 {
                                            self.viewport.renderer.zoom /= 1.1 * scalar_mult;
                                        } else {
                                            self.viewport.renderer.zoom *= 1.1 * scalar_mult;
                                        }
                                    }
                                    if self.viewport.active && self.events.enter.is_some() {
                                        println!("Rendering Now!");

                                        self.renderer.copy_args(&self.viewport.renderer);
                                        self.renderer.export_image_with_info(
                                            false,
                                            false,
                                            Some(self.viewport.renderer.rendered_samples),
                                            None,
                                        );
                                        self.renderer.clear();
                                        println!();
                                    }
                                    if mouse_input.primary_down() {
                                        ///mouse
                                        self.viewport.renderer.clear();
                                        let mut m: egui::Vec2 = egui::Vec2::new(0.0, 0.0);
                                        if let Some(o) = mouse_input.press_origin() {
                                            let ipxpos_o = Pos2::new(
                                                (o.x - l_space) * scalar,
                                                (o.y - t_space) * scalar,
                                            );
                                            m = Pos2::new(ipxpos.0, ipxpos.1) - ipxpos_o;
                                            m = egui::Vec2::new(m.x, m.y);
                                        }
                                        m.x = (m.x + 0.5) / self.viewport.renderer.size.0 as f32;
                                        m.y = (m.y + 0.5) / self.viewport.renderer.size.1 as f32;

                                        self.viewport.renderer.origin = self.viewport.last.origin
                                            - (Complex64::new(m.x as f64, (m.y as f64 / ratio))
                                                / self.viewport.renderer.zoom);
                                        pressed = true;
                                    }
                                    if mouse_input.secondary_down() {
                                        if self.temp_julia.is_none() {
                                            let mx = (ipxpos.0 + 0.5) as f64
                                                / self.viewport.renderer.size.0 as f64
                                                - 0.5;
                                            let my = (ipxpos.1 + 0.5) as f64
                                                / self.viewport.renderer.size.1 as f64
                                                - 0.5;
                                            self.viewport.renderer.args.julia = Some(
                                                (Complex64::new(mx as f64, my as f64 / ratio)
                                                    / self.viewport.renderer.zoom)
                                                    + self.viewport.renderer.origin,
                                            );
                                            pressed = true;
                                        }
                                        if mouse_input.middle_down()
                                            && self.temp_julia != self.viewport.renderer.args.julia
                                            && self.viewport.renderer.args.julia.is_some()
                                        {
                                            std::mem::swap(
                                                &mut self.temp_julia,
                                                &mut self.viewport.renderer.args.julia,
                                            );
                                            pressed = true;
                                        }
                                        if !self.events.m_middle.unwrap_or(true)
                                            && self.temp_julia != self.viewport.renderer.args.julia
                                            && self.temp_julia.is_some()
                                        {
                                            std::mem::swap(
                                                &mut self.temp_julia,
                                                &mut self.viewport.renderer.args.julia,
                                            );
                                            pressed = true;
                                        }
                                    }
                                    if mouse_input.any_released() {
                                        self.viewport.last.origin = self.viewport.renderer.origin;
                                    }
                                    if self.viewport.active {
                                        self.viewport.renderer.render(false, 1);
                                        ictx.request_repaint();
                                    }
                                }
                            }
                        });
                        if self.viewport.active && pressed {
                            self.viewport.renderer.clear();

                            self.viewport.renderer.render(false, 1);
                        }
                    });
                });
            });
            ui.vertical_centered(|ui| {
                let rect = ui.max_rect();
                let painter = ui.painter();
                // painter.rect_filled(rect, 0.0, Color32::from_rgb(16, 16, 16));
                // ui.button("ok");
                // ui.text_edit_multiline(&mut self.text);
                // let response = ui.add_sized(
                //     ui.available_size(),
                //     egui::TextEdit::multiline(TextEdit::multiline(text)),
                // );
                // ui.text_edit_multiline(&mut self.text).
                // ui.text_edit_multiline(&mut self.text)
                // ui.add(
                //     egui::TextEdit::multiline(&mut self.text)
                //         .font(egui::TextStyle::Monospace) // for cursor height
                //         .code_editor()
                //         .desired_rows(10)
                //         .lock_focus(true)
                //         .desired_width(f32::INFINITY),
                // );
            });